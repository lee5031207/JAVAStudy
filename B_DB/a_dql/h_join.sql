-- *** JOIN
-- 하나 이상의 테이블에서 테이블을 조회하기 위해 사용
-- 수행결과는 하나의 RESULT SET으로 나온다
-- 관계형 데이터베이스에서는 데이터의 중복을 최소화 하기 위해 
-- 최소한의 데이터를 테이블에 저장해드고, 필요할 때 테이블 간의 관계를 통해
-- 데이터를 조합해서 추출한다.

--1.직원번호 ,직원명, 부서코드, 부서명을 조회

--1-1.서브쿼리를 사용하는 방법 (비효율적)
SELECT EMP_ID, EMP_NAME, DEPT_CODE,
(SELECT DEPT_TITLE FROM DEPARTMENT WHERE DEPT_ID = E.DEPT_CODE) AS 부서명
FROM EMPLOYEE E;

--1-2. JOIN연산 활용
SELECT *--EMP_ID, EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE E JOIN DEPARTMENT D
ON(E.DEPT_CODE = D.DEPT_ID);


-- JOIN의 종류
-- CROSS JOIN, INNER JOIN, OUTER JOIN(LEFT JOIN, RIGHT JOIN)


-- 0. CROSS JOIN(안씀)
-- CARTEEN 곱이 발생해 사용하지 않는다
-- 한 쪽 테이블의 모든 행과 다른 테이블의 모든 행을 JOIN
-- EMPLOYEE 테이블의 ROW수 * DEPARTMENT 테이블의 ROW수 만큼의 ROW 생성
-- EX. 3만개 상품데이터와 5만개의 주문데이터를 CROSS JOIN하면 15억개의 ROW가 반환
-- 쥰내 비효율적 쓰지말자
SELECT * 
FROM EMPLOYEE CROSS JOIN DEPARTMENT
ORDER BY EMP_ID DESC, DEPT_ID ASC; 

-- 1. INNER JOIN(등가 조인(EQUALS JOIN))
-- JOIN 조건절 작성해서 조합하는 ROW들만 JOIN수행
-- ON() 안에 JOIN 조건절 작성
-- 만약에 조건절에서 사용할 두 테이블의 컬럼명이 같다면 USING(컬럼명) 사용 가능

--ANSI 표준 구문(미국 국립 표준 협회)
--ANSI 표준 쿼리는 모든 DBMS에서 공통적으로 사용하는 쿼리
SELECT *
FROM EMPLOYEE E  INNER JOIN JOB J ON (E.JOB_CODE = J.JOB_CODE);
--USING 사용
SELECT *
FROM EMPLOYEE E  JOIN JOB J USING(JOB_CODE);
--ORACLE 구문
SELECT *
FROM EMPLOYEE, JOB
WHERE EMPLOYEE.JOB_CODE = JOB.JOB_CODE;


--여러 테이블 JOIN해보기(ANSI)
-- EMPLOYEE, DEPARTMENT, LOCATION
SELECT * FROM EMPLOYEE E
INNER JOIN DEPARTMENT D ON(E.DEPT_CODE = D.DEPT_ID)
INNER JOIN LOCATION L ON (D.LOCATION_ID = L.LOCAL_CODE);

--여러 테이블 JOIN해보기(ORACLE)
-- EMPLOYEE, DEPARTMENT, LOCATION
SELECT * FROM EMPLOYEE E, DEPARTMENT D, LOCATION L
WHERE E.DEPT_CODE = D.DEPT_ID
AND D.LOCATION_ID = L.LOCAL_CODE;

--부서 테이블에서 부서별 지역명을 조회하세요(ANSI)
SELECT DEPT_ID, DEPT_TITLE, LOCAL_NAME FROM DEPARTMENT D
INNER JOIN LOCATION L ON (D.LOCATION_ID = L.LOCAL_CODE);

--부서 테이블에서 부서별 지역명을 조회하세요(ORACLE)
SELECT DEPT_TITLE, LOCAL_NAME
FROM DEPARTMENT D, LOCATION L
WHERE d.location_id = l.local_code;


---------------------------------------------------------------------------------------
-- *** OUTER JOIN
-- JOIN 조건절과 일치하지 않는 ROW도 JOIN에 포함 시킨다.
-- LEFT [OUTER] JOIN
-- RIGHT [OUTER] JOIN
-- FULL [OUTER] JOIN

--OUTER JOIN과 비교할 INNER JOIN 쿼리문 작성
SELECT  EMP_NAME, DEPT_TITLE, DEPT_CODE
FROM EMPLOYEE E
JOIN DEPARTMENT D ON(E.DEPT_CODE = D.DEPT_ID);

-- 새로운 직급 입력
--INSERT INTO JOB(JOB_CODE, JOB_NAME) VALUES ('J8','인턴');
--COMMIT;

--1) LEFT [OUTER] JOIN : FROM절에서 LEFT JOIN 구문 왼편 테이블을 기준으로 JOIN 발생
SELECT * FROM EMPLOYEE LEFT JOIN JOB USING (JOB_CODE); -- 23개나옴
SELECT * FROM JOB LEFT JOIN EMPLOYEE USING (JOB_CODE); -- 24개나옴 '인턴'까지

--2) RIGHT [OUTER] JOIN : FROM절에서 RIGHT JOIN 구문 오른편 테이블을 기준으로 JOIN 발생
SELECT * FROM EMPLOYEE RIGHT JOIN JOB USING (JOB_CODE); -- 24개나옴 '인턴'까지
SELECT * FROM JOB RIGHT JOIN EMPLOYEE USING (JOB_CODE); -- 23개나옴

--(ORACLE) LEFT, RIGHT 
-- LEFT/RIGHT 구분 X
SELECT * FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE(+) = J.JOB_CODE;

--3. FULL OUTER JOIN : 조인 조건절에 일치하지 않는 ROW를 양 테이블 모두 결과에 포함
SELECT  EMP_NAME, DEPT_TITLE, DEPT_CODE
FROM EMPLOYEE E
FULL OUTER JOIN DEPARTMENT D ON(E.DEPT_CODE = D.DEPT_ID);

--4. 비등가 조인(NON EQUAL JOIN)
-- 조인 조건절에 '=' 대신 다른 연산자를 사용하는 JOIN문
-- 조건절의 범위에 포함되는 행들을 연결 할 때 사용
SELECT EMP_NAME, SALARY, E.SAL_LEVEL, S.MIN_SAL, S.MAX_SAL
FROM EMPLOYEE E JOIN SAL_GRADE S
ON(E.SALARY <2500000);

--5. 자체조인(SELF JOIN)
-- 자기 자신과 JOIN하는 것
-- EMPLOYEE 테이블에서 사원의 이름, 부서코드, 관리자 사번, 관리자 이름을 출력하시오

-- SUBQUERY
SELECT EMP_NAME, DEPT_CODE, MANAGER_ID,
(SELECT EMP_NAME FROM EMPLOYEE WHERE EMP_ID = E.MANAGER_ID) AS 관리자명
FROM EMPLOYEE E;
-- SELFJOIN
SELECT E.EMP_NAME, E.DEPT_CODE, E.MANAGER_ID, E.EMP_NAME
FROM EMPLOYEE E JOIN EMPLOYEE M ON(E.MANAGER_ID = M.EMP_ID);


